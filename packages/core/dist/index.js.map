{"version":3,"sources":["../src/adapters/postgres.ts","../src/index.ts"],"names":["bcrypt","hash","base64url","calculateJwkThumbprint","jwtVerify","SignJWT"],"mappings":"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","file":"index.js","sourcesContent":["import type { Pool, PoolConfig } from \"pg\";\nimport type {\n  DatabaseAdapter,\n  User,\n  Credential,\n  Session,\n  VerificationToken,\n  RefreshToken,\n} from \"../types\";\n\n/**\n * PostgreSQL implementation of the DatabaseAdapter interface\n */\nexport class PostgresAdapter implements DatabaseAdapter {\n  private pool: Pool;\n\n  constructor(config: PoolConfig) {\n    if (!config) {\n      throw new Error(\"Database configuration is required\");\n    }\n    if (!config.database) {\n      throw new Error(\"Database name is required in configuration\");\n    }\n\n    // Configure connection pool with optimal defaults\n    const poolConfig = {\n      ...config,\n      max: config.max || 20, // Maximum pool size\n      idleTimeoutMillis: config.idleTimeoutMillis || 30000, // Close idle connections after 30s\n      connectionTimeoutMillis: config.connectionTimeoutMillis || 2000, // Connection timeout\n    };\n\n    // We use dynamic import to avoid bundling pg when not used\n    this.pool = new (require(\"pg\").Pool)(poolConfig);\n\n    // Setup pool error handler\n    this.pool.on(\"error\", (err) => {\n      console.error(\"Unexpected error on idle client\", err);\n    });\n  }\n\n  /**\n   * Initialize database with required tables\n   */\n  async init(): Promise<void> {\n    // Enable UUID extension if not enabled\n    await this.pool.query(`CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";`);\n\n    await this.pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        email TEXT UNIQUE NOT NULL,\n        email_verified_at TIMESTAMP WITH TIME ZONE,\n        active BOOLEAN DEFAULT true,\n        metadata JSONB,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,\n        deleted_at TIMESTAMP WITH TIME ZONE\n      );\n\n      -- Index for soft deletes\n      CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users(deleted_at) WHERE deleted_at IS NULL;\n\n      CREATE TABLE IF NOT EXISTS auth_credentials (\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n        type TEXT NOT NULL,\n        identifier TEXT NOT NULL,\n        credential TEXT NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        PRIMARY KEY (user_id, type)\n      );\n\n      CREATE TABLE IF NOT EXISTS auth_sessions (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL,\n        refresh_token TEXT NOT NULL,\n        last_active TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,\n        expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,\n        user_agent TEXT,\n        ip_address TEXT,\n        deleted_at TIMESTAMP WITH TIME ZONE\n      );\n\n      -- Index for faster session lookups by user\n      CREATE INDEX IF NOT EXISTS idx_auth_sessions_user_id \n      ON auth_sessions(user_id);\n\n      CREATE TABLE IF NOT EXISTS auth_refresh_tokens (\n        token TEXT PRIMARY KEY,\n        user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n        session_id UUID REFERENCES auth_sessions(id) ON DELETE CASCADE,\n        expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        revoked_at TIMESTAMP WITH TIME ZONE\n      );\n\n      -- Index for faster token lookups by user\n      CREATE INDEX IF NOT EXISTS idx_auth_refresh_tokens_user_id \n      ON auth_refresh_tokens(user_id);\n\n      CREATE TABLE IF NOT EXISTS auth_verification_tokens (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        identifier TEXT NOT NULL,\n        token TEXT NOT NULL,\n        type TEXT NOT NULL,\n        expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        metadata JSONB\n      );\n      \n      -- Index for faster lookups and soft uniqueness\n      CREATE INDEX IF NOT EXISTS idx_auth_verification_tokens_identifier \n      ON auth_verification_tokens(identifier);\n    `);\n  }\n\n  async createUser(\n    email: string,\n    metadata?: Record<string, any>\n  ): Promise<User> {\n    if (!email) {\n      throw new Error(\"Email is required\");\n    }\n    const result = await this.pool.query(\n      \"INSERT INTO users (email, metadata) VALUES ($1, $2) RETURNING *\",\n      [email.toLowerCase(), metadata ? JSON.stringify(metadata) : null]\n    );\n\n    return {\n      id: result.rows[0].id,\n      email: result.rows[0].email,\n      active: result.rows[0].active,\n      emailVerifiedAt: result.rows[0].email_verified_at,\n      metadata: result.rows[0].metadata,\n      createdAt: result.rows[0].created_at,\n    };\n  }\n\n  async createUsers(emails: string[]): Promise<User[]> {\n    const values = emails\n      .map((email, i) => `($${i + 1}, CURRENT_TIMESTAMP)`)\n      .join(\",\");\n\n    const result = await this.pool.query(\n      `INSERT INTO users (email, created_at)\n       VALUES ${values}\n       RETURNING *`,\n      emails.map((email) => email.toLowerCase())\n    );\n\n    return result.rows.map((row) => ({\n      id: row.id,\n      email: row.email,\n      active: row.active,\n      emailVerifiedAt: row.email_verified_at,\n      metadata: row.metadata,\n      createdAt: row.created_at,\n    }));\n  }\n\n  async getUserById(id: string): Promise<User | null> {\n    if (!id) {\n      throw new Error(\"User ID is required\");\n    }\n    if (\n      !/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        id\n      )\n    ) {\n      throw new Error(\"Invalid UUID format for user ID\");\n    }\n    console.log(`Getting user by ID: ${id}`);\n    const result = await this.pool.query(\n      \"SELECT * FROM users WHERE id = $1 AND deleted_at IS NULL\",\n      [id]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    return {\n      id: result.rows[0].id,\n      email: result.rows[0].email,\n      active: result.rows[0].active,\n      emailVerifiedAt: result.rows[0].email_verified_at,\n      metadata: result.rows[0].metadata,\n      createdAt: result.rows[0].created_at,\n    };\n  }\n\n  async getUserByEmail(email: string): Promise<User | null> {\n    console.log(`Getting user by email: ${email}`);\n    const result = await this.pool.query(\n      \"SELECT * FROM users WHERE email = $1 AND deleted_at IS NULL\",\n      [email.toLowerCase()]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    return {\n      id: result.rows[0].id,\n      email: result.rows[0].email,\n      active: result.rows[0].active,\n      emailVerifiedAt: result.rows[0].email_verified_at,\n      metadata: result.rows[0].metadata,\n      createdAt: result.rows[0].created_at,\n    };\n  }\n\n  async updateUser(id: string, data: Partial<User>): Promise<User> {\n    const setFields = [];\n    const values = [];\n    let paramCount = 1;\n\n    if (data.email !== undefined) {\n      setFields.push(`email = $${paramCount}`);\n      values.push(data.email.toLowerCase());\n      paramCount++;\n    }\n    if (data.active !== undefined) {\n      setFields.push(`active = $${paramCount}`);\n      values.push(data.active);\n      paramCount++;\n    }\n    if (data.emailVerifiedAt !== undefined) {\n      setFields.push(`email_verified_at = $${paramCount}`);\n      values.push(data.emailVerifiedAt);\n      paramCount++;\n    }\n    if (data.metadata !== undefined) {\n      setFields.push(`metadata = $${paramCount}`);\n      values.push(JSON.stringify(data.metadata));\n      paramCount++;\n    }\n\n    values.push(id);\n    const result = await this.pool.query(\n      `UPDATE users \n       SET ${setFields.join(\", \")}\n       WHERE id = $${paramCount}\n       RETURNING *`,\n      values\n    );\n\n    return {\n      id: result.rows[0].id,\n      email: result.rows[0].email,\n      active: result.rows[0].active,\n      emailVerifiedAt: result.rows[0].email_verified_at,\n      metadata: result.rows[0].metadata,\n      createdAt: result.rows[0].created_at,\n    };\n  }\n\n  async setUserMetadata(\n    id: string,\n    metadata: Record<string, any>\n  ): Promise<void> {\n    await this.pool.query(\"UPDATE users SET metadata = $1 WHERE id = $2\", [\n      JSON.stringify(metadata),\n      id,\n    ]);\n  }\n\n  async deleteCredentials(userId: string): Promise<void> {\n    await this.pool.query(\"DELETE FROM auth_credentials WHERE user_id = $1\", [\n      userId,\n    ]);\n  }\n\n  async deleteSessions(userId: string): Promise<void> {\n    await this.pool.query(\"DELETE FROM auth_sessions WHERE user_id = $1\", [\n      userId,\n    ]);\n  }\n\n  async transaction<T>(\n    callback: (trx: DatabaseAdapter) => Promise<T>\n  ): Promise<T> {\n    const client = await this.pool.connect();\n\n    // Create a transaction-scoped adapter that uses the client directly\n    const trxAdapter: DatabaseAdapter = {\n      ...this,\n      // Override methods to use transaction client instead of pool\n      createUser: async (...args) => {\n        const result = await client.query(\n          \"INSERT INTO users (email, metadata) VALUES ($1, $2) RETURNING *\",\n          [args[0].toLowerCase(), args[1] ? JSON.stringify(args[1]) : null]\n        );\n        return {\n          id: result.rows[0].id,\n          email: result.rows[0].email,\n          active: result.rows[0].active,\n          emailVerifiedAt: result.rows[0].email_verified_at,\n          metadata: result.rows[0].metadata,\n          createdAt: result.rows[0].created_at,\n        };\n      },\n      // Add other method overrides as needed\n      transaction: async (cb) => cb(trxAdapter), // Support nested transactions\n    };\n\n    try {\n      await client.query(\"BEGIN\");\n      const result = await callback(trxAdapter);\n      await client.query(\"COMMIT\");\n      return result;\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async deleteUser(id: string): Promise<void> {\n    console.log(`Soft deleting user with ID: ${id}`);\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Revoke all tokens\n      await client.query(\n        \"UPDATE auth_refresh_tokens SET revoked_at = CURRENT_TIMESTAMP WHERE user_id = $1\",\n        [id]\n      );\n\n      // Soft delete sessions\n      await client.query(\n        \"UPDATE auth_sessions SET deleted_at = CURRENT_TIMESTAMP WHERE user_id = $1\",\n        [id]\n      );\n\n      // Soft delete user\n      await client.query(\n        \"UPDATE users SET deleted_at = CURRENT_TIMESTAMP, active = false WHERE id = $1\",\n        [id]\n      );\n\n      await client.query(\"COMMIT\");\n      console.log(`User ${id} soft deleted successfully`);\n    } catch (error) {\n      console.error(`Error soft deleting user ${id}:`, error);\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async createCredential(\n    userId: string,\n    type: string,\n    identifier: string,\n    credential: string\n  ): Promise<void> {\n    if (!userId) {\n      throw new Error(\"User ID is required\");\n    }\n    if (!type) {\n      throw new Error(\"Credential type is required\");\n    }\n    if (!identifier) {\n      throw new Error(\"Credential identifier is required\");\n    }\n    if (!credential) {\n      throw new Error(\"Credential value is required\");\n    }\n\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Verify user exists\n      const userResult = await client.query(\n        \"SELECT id FROM users WHERE id = $1\",\n        [userId]\n      );\n      if (userResult.rows.length === 0) {\n        throw new Error(\"User not found\");\n      }\n\n      // Create credential\n      await client.query(\n        `INSERT INTO auth_credentials (user_id, type, identifier, credential)\n         VALUES ($1, $2, $3, $4)`,\n        [userId, type, identifier, credential]\n      );\n\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async getCredential(\n    userId: string,\n    type: string\n  ): Promise<Credential | null> {\n    const result = await this.pool.query(\n      \"SELECT * FROM auth_credentials WHERE user_id = $1 AND type = $2\",\n      [userId, type]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    return {\n      userId: result.rows[0].user_id,\n      type: result.rows[0].type,\n      identifier: result.rows[0].identifier,\n      credential: result.rows[0].credential,\n      createdAt: result.rows[0].created_at,\n      updatedAt: result.rows[0].updated_at,\n    };\n  }\n\n  async updateCredential(\n    userId: string,\n    type: string,\n    credential: string\n  ): Promise<void> {\n    if (!userId) {\n      throw new Error(\"User ID is required\");\n    }\n    if (!type) {\n      throw new Error(\"Credential type is required\");\n    }\n    if (!credential) {\n      throw new Error(\"Credential value is required\");\n    }\n\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Update credential and verify it exists\n      const result = await client.query(\n        `UPDATE auth_credentials \n         SET credential = $1, updated_at = CURRENT_TIMESTAMP\n         WHERE user_id = $2 AND type = $3\n         RETURNING id`,\n        [credential, userId, type]\n      );\n\n      if (result.rows.length === 0) {\n        throw new Error(\"Credential not found\");\n      }\n\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async createSession(\n    userId: string,\n    refreshToken: string,\n    metadata?: { userAgent?: string; ipAddress?: string }\n  ): Promise<Session> {\n    if (!userId) {\n      throw new Error(\"User ID is required\");\n    }\n    if (!refreshToken) {\n      throw new Error(\"Refresh token is required\");\n    }\n    const result = await this.pool.query(\n      `INSERT INTO auth_sessions \n       (id, user_id, refresh_token, expires_at, user_agent, ip_address)\n       VALUES (uuid_generate_v4(), $1, $2, $3, $4, $5)\n       RETURNING *`,\n      [\n        userId,\n        refreshToken,\n        new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\n        metadata?.userAgent,\n        metadata?.ipAddress,\n      ]\n    );\n\n    return {\n      id: result.rows[0].id,\n      userId: result.rows[0].user_id,\n      refreshToken: result.rows[0].refresh_token,\n      lastActive: result.rows[0].last_active,\n      expiresAt: result.rows[0].expires_at,\n      createdAt: result.rows[0].created_at,\n      userAgent: result.rows[0].user_agent,\n      ipAddress: result.rows[0].ip_address,\n    };\n  }\n\n  async getSession(id: string): Promise<Session | null> {\n    const result = await this.pool.query(\n      \"SELECT * FROM auth_sessions WHERE id = $1\",\n      [id]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    return {\n      id: result.rows[0].id,\n      userId: result.rows[0].user_id,\n      refreshToken: result.rows[0].refresh_token,\n      lastActive: result.rows[0].last_active,\n      expiresAt: result.rows[0].expires_at,\n      createdAt: result.rows[0].created_at,\n      userAgent: result.rows[0].user_agent,\n      ipAddress: result.rows[0].ip_address,\n    };\n  }\n\n  async updateSessionActivity(id: string): Promise<void> {\n    await this.pool.query(\n      \"UPDATE auth_sessions SET last_active = CURRENT_TIMESTAMP WHERE id = $1\",\n      [id]\n    );\n  }\n\n  async getUserSessions(userId: string): Promise<Session[]> {\n    const result = await this.pool.query(\n      \"SELECT * FROM auth_sessions WHERE user_id = $1 ORDER BY last_active DESC\",\n      [userId]\n    );\n\n    return result.rows.map((row) => ({\n      id: row.id,\n      userId: row.user_id,\n      refreshToken: row.refresh_token,\n      lastActive: row.last_active,\n      expiresAt: row.expires_at,\n      createdAt: row.created_at,\n      userAgent: row.user_agent,\n      ipAddress: row.ip_address,\n    }));\n  }\n\n  async createRefreshToken(\n    sessionId: string,\n    userId: string,\n    token: string,\n    expiresAt: Date\n  ): Promise<RefreshToken> {\n    if (!sessionId) {\n      throw new Error(\"Session ID is required\");\n    }\n    if (!userId) {\n      throw new Error(\"User ID is required\");\n    }\n    if (!token) {\n      throw new Error(\"Token value is required\");\n    }\n    if (!expiresAt) {\n      throw new Error(\"Expiration date is required\");\n    }\n    if (expiresAt.getTime() <= Date.now()) {\n      throw new Error(\"Expiration date must be in the future\");\n    }\n    const result = await this.pool.query(\n      `INSERT INTO auth_refresh_tokens (token, user_id, session_id, expires_at)\n       VALUES ($1, $2, $3, $4)\n       RETURNING *`,\n      [token, userId, sessionId, expiresAt]\n    );\n\n    return {\n      token: result.rows[0].token,\n      userId: result.rows[0].user_id,\n      sessionId: result.rows[0].session_id,\n      expiresAt: result.rows[0].expires_at,\n      createdAt: result.rows[0].created_at,\n      revokedAt: result.rows[0].revoked_at,\n    };\n  }\n\n  async getRefreshToken(token: string): Promise<RefreshToken | null> {\n    const result = await this.pool.query(\n      \"SELECT * FROM auth_refresh_tokens WHERE token = $1\",\n      [token]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    return {\n      token: result.rows[0].token,\n      userId: result.rows[0].user_id,\n      sessionId: result.rows[0].session_id,\n      expiresAt: result.rows[0].expires_at,\n      createdAt: result.rows[0].created_at,\n      revokedAt: result.rows[0].revoked_at,\n    };\n  }\n\n  async revokeRefreshToken(token: string): Promise<void> {\n    if (!token) {\n      throw new Error(\"Token is required\");\n    }\n\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Get token info\n      const tokenResult = await client.query(\n        \"SELECT session_id FROM auth_refresh_tokens WHERE token = $1\",\n        [token]\n      );\n\n      if (tokenResult.rows.length === 0) {\n        throw new Error(\"Token not found\");\n      }\n\n      // Revoke token\n      await client.query(\n        \"UPDATE auth_refresh_tokens SET revoked_at = CURRENT_TIMESTAMP WHERE token = $1\",\n        [token]\n      );\n\n      // Update session last_active\n      await client.query(\n        \"UPDATE auth_sessions SET last_active = CURRENT_TIMESTAMP WHERE id = $1\",\n        [tokenResult.rows[0].session_id]\n      );\n\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async revokeUserRefreshTokens(userId: string): Promise<void> {\n    await this.pool.query(\n      \"UPDATE auth_refresh_tokens SET revoked_at = CURRENT_TIMESTAMP WHERE user_id = $1\",\n      [userId]\n    );\n  }\n\n  async deleteSession(id: string): Promise<void> {\n    await this.pool.query(\"DELETE FROM auth_sessions WHERE id = $1\", [id]);\n  }\n\n  async createVerificationToken(\n    identifier: string,\n    token: string,\n    type: \"email\" | \"password_reset\",\n    expiresAt: Date,\n    metadata?: Record<string, any>\n  ): Promise<void> {\n    if (!identifier) {\n      throw new Error(\"Identifier is required\");\n    }\n    if (!token) {\n      throw new Error(\"Token value is required\");\n    }\n    if (!type) {\n      throw new Error(\"Token type is required\");\n    }\n    if (![\"email\", \"password_reset\"].includes(type)) {\n      throw new Error(\n        \"Invalid token type. Must be 'email' or 'password_reset'\"\n      );\n    }\n    if (!expiresAt) {\n      throw new Error(\"Expiration date is required\");\n    }\n    if (expiresAt.getTime() <= Date.now()) {\n      throw new Error(\"Expiration date must be in the future\");\n    }\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Delete any existing tokens for this identifier\n      await client.query(\n        `DELETE FROM auth_verification_tokens \n         WHERE identifier = $1`,\n        [identifier]\n      );\n\n      // Create new token\n      await client.query(\n        `INSERT INTO auth_verification_tokens (identifier, token, type, expires_at, metadata)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [\n          identifier,\n          token,\n          type,\n          expiresAt,\n          metadata ? JSON.stringify(metadata) : null,\n        ]\n      );\n\n      // Cleanup expired tokens older than 24 hours\n      await client.query(\n        `DELETE FROM auth_verification_tokens \n         WHERE expires_at < CURRENT_TIMESTAMP \n         AND created_at < CURRENT_TIMESTAMP - INTERVAL '24 hours'`\n      );\n\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async useVerificationToken(\n    identifier: string,\n    token: string\n  ): Promise<boolean> {\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n\n      // Get and delete the verification token\n      const result = await client.query(\n        `DELETE FROM auth_verification_tokens\n         WHERE identifier = $1 \n         AND token = $2\n         AND expires_at > CURRENT_TIMESTAMP\n         RETURNING type, identifier`,\n        [identifier, token]\n      );\n\n      if (result.rows.length === 0) {\n        await client.query(\"ROLLBACK\");\n        return false;\n      }\n\n      const { type, identifier: email } = result.rows[0];\n\n      // Handle different token types\n      if (type === \"email\") {\n        // Update user's email verification status\n        await client.query(\n          `UPDATE users \n           SET email_verified_at = CURRENT_TIMESTAMP \n           WHERE email = $1`,\n          [email]\n        );\n      }\n      // Note: For password_reset type, the actual password update is handled separately\n      // since we don't want to store the new password in the verification token\n\n      await client.query(\"COMMIT\");\n      return true;\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  /**\n   * Close database connection\n   */\n  async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n","import {\n  SignJWT,\n  jwtVerify,\n  calculateJwkThumbprint,\n  importJWK,\n  generateKeyPair,\n  generateSecret,\n  base64url,\n} from \"jose\";\nimport * as bcrypt from \"bcrypt\";\nimport type {\n  AuthConfig,\n  AuthResult,\n  DatabaseAdapter,\n  User,\n  Credential,\n  CryptoAdapter,\n  TokenPair,\n  RefreshResult,\n  PKCEChallenge,\n  Session,\n} from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./adapters/postgres\";\n\n// Platform-agnostic crypto implementation using jose and bcrypt\nclass DefaultCryptoAdapter implements CryptoAdapter {\n  randomBytes(size: number): Uint8Array {\n    // Use crypto.getRandomValues for true randomness\n    const bytes = new Uint8Array(size);\n    crypto.getRandomValues(bytes);\n    return bytes;\n  }\n\n  async hash(data: string, salt: string): Promise<string> {\n    // Use bcrypt for secure password hashing\n    const saltRounds = 10;\n    return await bcrypt.hash(data, saltRounds);\n  }\n\n  async verifyHash(data: string, hash: string): Promise<boolean> {\n    // Use bcrypt to verify hashed passwords\n    return await bcrypt.compare(data, hash);\n  }\n\n  async generatePKCEChallenge(): Promise<PKCEChallenge> {\n    const verifierBytes = this.randomBytes(32);\n    const verifier = base64url.encode(verifierBytes);\n\n    // Generate challenge using JWT thumbprint\n    const jwk = { kty: \"oct\", k: verifier, alg: \"HS256\" };\n    const challenge = await calculateJwkThumbprint(jwk);\n\n    return {\n      codeVerifier: verifier,\n      codeChallenge: challenge,\n      codeChallengeMethod: \"S256\",\n    };\n  }\n\n  async verifyPKCEChallenge(\n    verifier: string,\n    challenge: string\n  ): Promise<boolean> {\n    const jwk = { kty: \"oct\", k: verifier, alg: \"HS256\" };\n    const computedChallenge = await calculateJwkThumbprint(jwk);\n    return challenge === computedChallenge;\n  }\n}\n\n/**\n * Core authentication class that handles all auth operations\n */\nexport class Auth {\n  private secret: Uint8Array;\n  private accessTokenExpiry: number;\n  private refreshTokenExpiry: number;\n  private sessionExpiry: number;\n  private secureCookies: boolean;\n  private crypto: CryptoAdapter;\n\n  constructor(\n    private db: DatabaseAdapter,\n    config: AuthConfig\n  ) {\n    this.secret = new TextEncoder().encode(config.secret);\n    this.accessTokenExpiry = config.accessTokenExpiry || 15 * 60; // 15 minutes default\n    this.refreshTokenExpiry = config.refreshTokenExpiry || 7 * 24 * 60 * 60; // 7 days default\n    this.sessionExpiry = config.sessionExpiry || 30 * 24 * 60 * 60; // 30 days default\n    this.secureCookies = config.secureCookies ?? true;\n    this.crypto = config.crypto || new DefaultCryptoAdapter();\n  }\n\n  /**\n   * Register a new user with email/password\n   */\n  async register(\n    email: string,\n    password: string,\n    metadata?: {\n      userAgent?: string;\n      ipAddress?: string;\n      userData?: Record<string, any>;\n    }\n  ): Promise<AuthResult> {\n    try {\n      // Check if user exists\n      const existing = await this.db.getUserByEmail(email);\n      if (existing) {\n        return { success: false, error: \"User already exists\" };\n      }\n\n      // Create user with metadata\n      const user = await this.db.createUser(email, metadata?.userData);\n\n      // Hash password and create credential\n      const hashedPassword = await this.crypto.hash(password, \"\");\n      await this.db.createCredential(\n        user.id,\n        \"password\",\n        email,\n        hashedPassword\n      );\n\n      // Generate tokens and create session\n      const tokens = await this.generateTokenPair(user);\n      const session = await this.createSession(\n        user.id,\n        tokens.refreshToken,\n        metadata\n      );\n\n      return {\n        success: true,\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        session,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Registration failed\",\n      };\n    }\n  }\n\n  /**\n   * Login with email/password\n   */\n  async login(\n    email: string,\n    password: string,\n    metadata?: { userAgent?: string; ipAddress?: string }\n  ): Promise<AuthResult> {\n    try {\n      // Get user\n      const user = await this.db.getUserByEmail(email);\n      if (!user) {\n        return { success: false, error: \"Authentication failed\" };\n      }\n\n      // Get password credential\n      const credential = await this.db.getCredential(user.id, \"password\");\n      if (!credential) {\n        return { success: false, error: \"Authentication failed\" };\n      }\n\n      // Verify password using bcrypt\n      const isValid = await this.crypto.verifyHash(\n        password,\n        credential.credential\n      );\n      if (!isValid) {\n        return { success: false, error: \"Authentication failed\" };\n      }\n\n      // Generate tokens and create session\n      const tokens = await this.generateTokenPair(user);\n      const session = await this.createSession(\n        user.id,\n        tokens.refreshToken,\n        metadata\n      );\n\n      return {\n        success: true,\n        accessToken: tokens.accessToken,\n        refreshToken: tokens.refreshToken,\n        session,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Login failed\",\n      };\n    }\n  }\n\n  /**\n   * Verify an access token\n   */\n  async verifyToken(token: string): Promise<User | null> {\n    try {\n      const { payload } = await jwtVerify(token, this.secret);\n      if (!payload.sub || payload.type !== \"access\") return null;\n\n      const user = await this.db.getUserById(payload.sub);\n      return user;\n    } catch (error) {\n      console.error(\"Token verification failed:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Refresh an access token using a refresh token\n   */\n  async refreshToken(refreshToken: string): Promise<RefreshResult> {\n    try {\n      // Verify refresh token exists and is not revoked\n      const storedToken = await this.db.getRefreshToken(refreshToken);\n      if (!storedToken || storedToken.revokedAt) {\n        return { success: false, error: \"Invalid refresh token\" };\n      }\n\n      // Check if token is expired\n      if (storedToken.expiresAt < new Date()) {\n        await this.db.revokeRefreshToken(refreshToken);\n        return { success: false, error: \"Refresh token expired\" };\n      }\n\n      // Get user\n      const user = await this.db.getUserById(storedToken.userId);\n      if (!user) {\n        return { success: false, error: \"User not found\" };\n      }\n\n      // Generate new token pair\n      const tokens = await this.generateTokenPair(user);\n\n      // Revoke old refresh token and create new one\n      await this.db.revokeRefreshToken(refreshToken);\n      await this.createSession(user.id, tokens.refreshToken);\n\n      return { success: true, tokens };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Token refresh failed\",\n      };\n    }\n  }\n\n  /**\n   * Logout user by revoking their refresh token\n   */\n  async logout(refreshToken: string): Promise<void> {\n    await this.db.revokeRefreshToken(refreshToken);\n  }\n\n  /**\n   * Logout user from all devices by revoking all refresh tokens\n   */\n  async logoutAll(userId: string): Promise<void> {\n    await this.db.revokeUserRefreshTokens(userId);\n  }\n\n  /**\n   * Generate a verification token for email/phone verification\n   */\n  async generateVerificationToken(\n    identifier: string,\n    type: \"email\" | \"password_reset\" = \"email\",\n    metadata?: Record<string, any>\n  ): Promise<string> {\n    // Generate random 6 digit number (100000-999999)\n    const randomBytes = this.crypto.randomBytes(4);\n    const number =\n      (((randomBytes[0] |\n        (randomBytes[1] << 8) |\n        (randomBytes[2] << 16) |\n        ((randomBytes[3] & 0x7f) << 24)) >>>\n        0) %\n        900000) +\n      100000;\n    const token = number.toString();\n\n    // Store verification token\n    const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes\n    await this.db.createVerificationToken(\n      identifier,\n      token,\n      type,\n      expiresAt,\n      metadata\n    );\n\n    return token;\n  }\n\n  /**\n   * Verify a verification token\n   */\n  async verifyVerificationToken(\n    identifier: string,\n    token: string\n  ): Promise<boolean> {\n    return this.db.useVerificationToken(identifier, token);\n  }\n\n  /**\n   * Helper to generate access and refresh tokens\n   */\n  private async generateTokenPair(user: User): Promise<TokenPair> {\n    const accessToken = await new SignJWT({ email: user.email, type: \"access\" })\n      .setProtectedHeader({ alg: \"HS256\" })\n      .setSubject(user.id)\n      .setIssuedAt()\n      .setExpirationTime(`${this.accessTokenExpiry}s`)\n      .sign(this.secret);\n\n    const refreshToken = Array.from(this.crypto.randomBytes(32))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n\n    return { accessToken, refreshToken };\n  }\n\n  /**\n   * Helper to create a new session with refresh token\n   */\n  private async createSession(\n    userId: string,\n    refreshToken: string,\n    metadata?: { userAgent?: string; ipAddress?: string }\n  ): Promise<Session> {\n    const expiresAt = new Date(Date.now() + this.sessionExpiry * 1000);\n    const session = await this.db.createSession(userId, refreshToken, metadata);\n\n    await this.db.createRefreshToken(\n      session.id,\n      userId,\n      refreshToken,\n      new Date(Date.now() + this.refreshTokenExpiry * 1000)\n    );\n\n    return session;\n  }\n}\n"]}